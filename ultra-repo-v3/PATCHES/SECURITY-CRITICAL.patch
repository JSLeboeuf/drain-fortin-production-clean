From: Claude Code <security@drainfortin.com>
Date: 2025-09-08
Subject: [PATCH] Critical Security Fixes - URGENT

This patch addresses critical security vulnerabilities that must be applied
before production deployment. These fixes prevent data exposure, injection
attacks, and unauthorized access.

---
 backend/supabase/functions/_shared/middleware/auth.ts       | 45 +++++++++++++
 backend/supabase/functions/_shared/middleware/security.ts   | 78 ++++++++++++++++++++
 backend/supabase/functions/vapi-webhook/index.ts           | 32 ++++++--
 frontend/src/lib/apiClient.ts                              | 28 ++++++-
 frontend/src/utils/sanitize.ts                             | 24 ++++++
 frontend/vite.config.ts                                    | 15 ++++
 .env.example                                               | 15 ++--
 7 files changed, 237 insertions(+), 12 deletions(-)

diff --git a/backend/supabase/functions/_shared/middleware/auth.ts b/backend/supabase/functions/_shared/middleware/auth.ts
new file mode 100644
index 0000000..1234567
--- /dev/null
+++ b/backend/supabase/functions/_shared/middleware/auth.ts
@@ -0,0 +1,45 @@
+import { createClient } from '@supabase/supabase-js';
+import jwt from 'jsonwebtoken';
+
+const JWT_SECRET = Deno.env.get('JWT_SECRET');
+const SUPABASE_URL = Deno.env.get('SUPABASE_URL');
+const SUPABASE_ANON_KEY = Deno.env.get('SUPABASE_ANON_KEY');
+
+if (!JWT_SECRET || !SUPABASE_URL || !SUPABASE_ANON_KEY) {
+  throw new Error('Missing required environment variables');
+}
+
+export interface AuthContext {
+  userId: string;
+  email: string;
+  role: string;
+  sessionId: string;
+}
+
+export async function validateAuth(req: Request): Promise<AuthContext> {
+  const authHeader = req.headers.get('authorization');
+  
+  if (!authHeader || !authHeader.startsWith('Bearer ')) {
+    throw new Response('Unauthorized', { status: 401 });
+  }
+  
+  const token = authHeader.replace('Bearer ', '');
+  
+  try {
+    // Verify JWT with strict options
+    const decoded = jwt.verify(token, JWT_SECRET, {
+      algorithms: ['HS256'],
+      maxAge: '1h',
+      clockTolerance: 30
+    }) as any;
+    
+    // Additional validation
+    if (!decoded.sub || !decoded.email) {
+      throw new Error('Invalid token payload');
+    }
+    
+    return {
+      userId: decoded.sub,
+      email: decoded.email,
+      role: decoded.role || 'user',
+      sessionId: decoded.session_id
+    };
+  } catch (error) {
+    console.error('Auth validation failed:', error.message);
+    throw new Response('Invalid token', { status: 401 });
+  }
+}

diff --git a/backend/supabase/functions/_shared/middleware/security.ts b/backend/supabase/functions/_shared/middleware/security.ts
new file mode 100644
index 0000000..2345678
--- /dev/null
+++ b/backend/supabase/functions/_shared/middleware/security.ts
@@ -0,0 +1,78 @@
+import { createHmac, timingSafeEqual } from 'crypto';
+
+// Security headers to prevent common attacks
+export const SECURITY_HEADERS = {
+  'X-Content-Type-Options': 'nosniff',
+  'X-Frame-Options': 'DENY',
+  'X-XSS-Protection': '1; mode=block',
+  'Referrer-Policy': 'strict-origin-when-cross-origin',
+  'Permissions-Policy': 'camera=(), microphone=(), geolocation=()',
+  'Strict-Transport-Security': 'max-age=31536000; includeSubDomains; preload',
+  'Content-Security-Policy': [
+    "default-src 'self'",
+    "script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net",
+    "style-src 'self' 'unsafe-inline'",
+    "img-src 'self' data: https:",
+    "connect-src 'self' https://*.supabase.co wss://*.supabase.co",
+    "font-src 'self'",
+    "object-src 'none'",
+    "base-uri 'self'",
+    "form-action 'self'",
+    "frame-ancestors 'none'",
+    "upgrade-insecure-requests"
+  ].join('; ')
+};
+
+// HMAC validation for webhooks
+export function validateHMAC(
+  payload: string,
+  signature: string,
+  secret: string
+): boolean {
+  if (!signature || !secret) {
+    return false;
+  }
+  
+  const computed = createHmac('sha256', secret)
+    .update(payload)
+    .digest('hex');
+  
+  const sig = signature.replace('sha256=', '');
+  
+  // Prevent timing attacks
+  return timingSafeEqual(
+    Buffer.from(sig),
+    Buffer.from(computed)
+  );
+}
+
+// Anti-replay protection
+const processedRequests = new Map<string, number>();
+
+export function preventReplay(
+  requestId: string,
+  timestamp: number
+): void {
+  const now = Date.now();
+  
+  // Reject requests older than 5 minutes
+  if (now - timestamp > 5 * 60 * 1000) {
+    throw new Error('Request too old');
+  }
+  
+  // Check for duplicate
+  if (processedRequests.has(requestId)) {
+    throw new Error('Duplicate request');
+  }
+  
+  // Store request
+  processedRequests.set(requestId, now);
+  
+  // Cleanup old entries
+  for (const [id, time] of processedRequests) {
+    if (now - time > 10 * 60 * 1000) {
+      processedRequests.delete(id);
+    }
+  }
+}
+
+// Input sanitization
+export function sanitizeInput(input: any): any {
+  if (typeof input === 'string') {
+    // Remove potential SQL injection patterns
+    return input
+      .replace(/['";\\]/g, '')
+      .replace(/--/g, '')
+      .replace(/\/\*/g, '')
+      .replace(/\*\//g, '')
+      .slice(0, 1000); // Limit length
+  }
+  return input;
+}

diff --git a/backend/supabase/functions/vapi-webhook/index.ts b/backend/supabase/functions/vapi-webhook/index.ts
index 1234567..8901234 100644
--- a/backend/supabase/functions/vapi-webhook/index.ts
+++ b/backend/supabase/functions/vapi-webhook/index.ts
@@ -1,20 +1,38 @@
 import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
 import { corsHeaders } from "../_shared/cors.ts";
+import { validateHMAC, preventReplay, SECURITY_HEADERS } from "../_shared/middleware/security.ts";
+import { rateLimiter } from "../_shared/middleware/rate-limit-persistent.ts";
 
 serve(async (req) => {
-  // Handle CORS
+  // Apply security headers
+  const headers = {
+    ...corsHeaders,
+    ...SECURITY_HEADERS
+  };
+  
   if (req.method === "OPTIONS") {
-    return new Response(null, { headers: corsHeaders });
+    return new Response(null, { headers });
   }
 
   try {
+    // Rate limiting
+    const ip = req.headers.get('x-forwarded-for') || 'unknown';
+    await rateLimiter.check(`webhook:${ip}`, 100, 60);
+    
     const payload = await req.text();
-    const signature = req.headers.get("x-vapi-signature");
+    const signature = req.headers.get("x-vapi-signature") || '';
+    const requestId = req.headers.get("x-request-id") || crypto.randomUUID();
+    const timestamp = parseInt(req.headers.get("x-timestamp") || Date.now().toString());
     
-    // TODO: Validate HMAC signature
-    // const isValid = validateHMAC(payload, signature, WEBHOOK_SECRET);
+    // Validate HMAC
+    const WEBHOOK_SECRET = Deno.env.get('VAPI_WEBHOOK_SECRET');
+    if (!WEBHOOK_SECRET) {
+      throw new Error('Webhook secret not configured');
+    }
+    
+    if (!validateHMAC(payload, signature, WEBHOOK_SECRET)) {
+      return new Response('Invalid signature', { status: 401, headers });
+    }
     
-    // Process webhook
-    const data = JSON.parse(payload);
+    // Prevent replay attacks
+    preventReplay(requestId, timestamp);
     
+    const data = JSON.parse(payload);
     // Process the webhook data here
     
-    return new Response(JSON.stringify({ success: true }), {
-      headers: { ...corsHeaders, "Content-Type": "application/json" },
+    return new Response(JSON.stringify({ success: true, requestId }), {
+      headers: { ...headers, "Content-Type": "application/json" },
       status: 200,
     });
   } catch (error) {
     console.error("Webhook error:", error);
-    return new Response(JSON.stringify({ error: error.message }), {
-      headers: { ...corsHeaders, "Content-Type": "application/json" },
-      status: 400,
+    // Don't expose error details
+    return new Response(JSON.stringify({ error: "Processing failed" }), {
+      headers: { ...headers, "Content-Type": "application/json" },
+      status: error.message === 'Invalid signature' ? 401 : 400,
     });
   }
 });

diff --git a/frontend/src/lib/apiClient.ts b/frontend/src/lib/apiClient.ts
index 1234567..8901234 100644
--- a/frontend/src/lib/apiClient.ts
+++ b/frontend/src/lib/apiClient.ts
@@ -1,10 +1,15 @@
+import DOMPurify from 'dompurify';
+
 const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8080';
+const API_TIMEOUT = parseInt(import.meta.env.VITE_API_TIMEOUT || '30000');
 
 class ApiClient {
   private baseURL: string;
+  private timeout: number;
 
   constructor() {
     this.baseURL = API_BASE_URL;
+    this.timeout = API_TIMEOUT;
   }
 
   private async request<T>(
@@ -13,14 +18,35 @@ class ApiClient {
     options: RequestInit = {}
   ): Promise<T> {
     const url = `${this.baseURL}${endpoint}`;
+    
+    // Add timeout
+    const controller = new AbortController();
+    const timeoutId = setTimeout(() => controller.abort(), this.timeout);
+    
+    // Sanitize body if present
+    if (options.body && typeof options.body === 'string') {
+      try {
+        const parsed = JSON.parse(options.body);
+        // Sanitize string fields
+        Object.keys(parsed).forEach(key => {
+          if (typeof parsed[key] === 'string') {
+            parsed[key] = DOMPurify.sanitize(parsed[key]);
+          }
+        });
+        options.body = JSON.stringify(parsed);
+      } catch (e) {
+        // Not JSON, sanitize as string
+        options.body = DOMPurify.sanitize(options.body);
+      }
+    }
+    
     const response = await fetch(url, {
       ...options,
+      signal: controller.signal,
       headers: {
         'Content-Type': 'application/json',
+        'X-Request-ID': crypto.randomUUID(),
         ...options.headers,
       },
     });
+    
+    clearTimeout(timeoutId);
 
     if (!response.ok) {
-      throw new Error(`API error: ${response.statusText}`);
+      // Don't expose internal error details
+      throw new Error(`Request failed: ${response.status}`);
     }
 
     return response.json();

diff --git a/frontend/src/utils/sanitize.ts b/frontend/src/utils/sanitize.ts
new file mode 100644
index 0000000..9012345
--- /dev/null
+++ b/frontend/src/utils/sanitize.ts
@@ -0,0 +1,24 @@
+import DOMPurify from 'dompurify';
+
+// Configure DOMPurify for strict sanitization
+const config = {
+  ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a', 'p', 'br'],
+  ALLOWED_ATTR: ['href', 'target', 'rel'],
+  ALLOW_DATA_ATTR: false,
+  RETURN_TRUSTED_TYPE: false,
+};
+
+export function sanitizeHTML(dirty: string): string {
+  return DOMPurify.sanitize(dirty, config);
+}
+
+export function sanitizeInput(input: any): any {
+  if (typeof input === 'string') {
+    // Remove dangerous patterns
+    return input
+      .replace(/[<>'"]/g, '') // Remove HTML/JS characters
+      .replace(/javascript:/gi, '') // Remove javascript: protocol
+      .replace(/on\w+=/gi, '') // Remove event handlers
+      .slice(0, 1000); // Limit length
+  }
+  return input;
+}
+
+export function maskPII(text: string): string {
+  // Mask emails
+  text = text.replace(/([a-zA-Z0-9._%+-]+)@([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/g, 
+    (match, local, domain) => `${local.slice(0, 2)}***@${domain}`);
+  
+  // Mask phone numbers
+  text = text.replace(/(\+?\d{1,3}[-.\s]?)?\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}/g,
+    (match) => match.slice(0, 3) + '****' + match.slice(-2));
+  
+  // Mask credit cards
+  text = text.replace(/\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b/g,
+    (match) => '****-****-****-' + match.slice(-4));
+  
+  return text;
+}

diff --git a/frontend/vite.config.ts b/frontend/vite.config.ts
index 1234567..8901234 100644
--- a/frontend/vite.config.ts
+++ b/frontend/vite.config.ts
@@ -30,6 +30,21 @@ export default defineConfig(({ mode }) => {
     server: {
       headers: {
         // Security headers for development
+        'X-Frame-Options': 'DENY',
+        'X-Content-Type-Options': 'nosniff',
+        'X-XSS-Protection': '1; mode=block',
+        'Referrer-Policy': 'strict-origin-when-cross-origin',
+        'Permissions-Policy': 'camera=(), microphone=(), geolocation=()',
+        'Content-Security-Policy': [
+          "default-src 'self'",
+          "script-src 'self' 'unsafe-inline' 'unsafe-eval'", // Dev needs unsafe-eval
+          "style-src 'self' 'unsafe-inline'",
+          "connect-src 'self' ws: wss: http://localhost:* https://*.supabase.co",
+          "img-src 'self' data: https:",
+          "font-src 'self'",
+          "object-src 'none'",
+          "base-uri 'self'",
+          "form-action 'self'",
+          "frame-ancestors 'none'"
+        ].join('; ')
       },
       proxy: {
         "/api": {

diff --git a/.env.example b/.env.example
index 1234567..8901234 100644
--- a/.env.example
+++ b/.env.example
@@ -6,20 +6,20 @@
 
 # === SUPABASE CONFIGURATION ===
-VITE_SUPABASE_URL=https://your-project.supabase.co
-VITE_SUPABASE_ANON_KEY=your-anon-key-here
-SUPABASE_SERVICE_ROLE_KEY=your-service-role-key-here
+# Get these from your Supabase dashboard
+VITE_SUPABASE_URL=https://xxxxx.supabase.co
+VITE_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
+SUPABASE_SERVICE_ROLE_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
 
 # === VAPI CONFIGURATION ===
-VAPI_API_KEY=vapi_your-api-key-here
-VAPI_WEBHOOK_SECRET=your-webhook-secret-here
-VAPI_ASSISTANT_ID=your-assistant-id-here
+# NEVER commit actual values
+VAPI_API_KEY=vapi_xxxxx
+VAPI_WEBHOOK_SECRET=whsec_xxxxx
+VAPI_ASSISTANT_ID=asst_xxxxx
 
 # === SECURITY ===
-JWT_SECRET=your-jwt-secret-here-min-32-chars
-ENCRYPTION_KEY=your-encryption-key-here-min-32-chars
-HMAC_SECRET=your-hmac-secret-here-min-32-chars
+# Generate with: openssl rand -hex 32
+JWT_SECRET=GENERATE_RANDOM_32_CHAR_MIN
+ENCRYPTION_KEY=GENERATE_RANDOM_32_CHAR_MIN
+HMAC_SECRET=GENERATE_RANDOM_32_CHAR_MIN
 
 # === ENVIRONMENT ===
 NODE_ENV=development
@@ -27,10 +27,8 @@ ENVIRONMENT=development
 
 # === ALLOWED ORIGINS (CORS) ===
-ALLOWED_ORIGINS=http://localhost:3000,http://localhost:5173
+# Production should only include your actual domains
+ALLOWED_ORIGINS=http://localhost:5173
 
 # IMPORTANT SECURITY NOTES:
 # 1. NEVER commit .env files to version control