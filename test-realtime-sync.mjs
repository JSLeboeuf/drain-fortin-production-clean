/**
 * TEST DE SYNCHRONISATION TEMPS R√âEL - DRAIN FORTIN
 * 
 * Ce script teste la synchronisation compl√®te entre:
 * - VAPI (r√©ception d'appels)
 * - Supabase (base de donn√©es)
 * - Frontend React (interface temps r√©el)
 * 
 * Validation crois√©e avec drainfortin.ca
 */

import { createClient } from '@supabase/supabase-js';
import fetch from 'node-fetch';
import dotenv from 'dotenv';

dotenv.config();

// Configuration Supabase
const supabaseUrl = process.env.SUPABASE_URL;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
const supabase = createClient(supabaseUrl, supabaseServiceKey);

// Configuration VAPI
const VAPI_API_KEY = process.env.VAPI_API_KEY;
const VAPI_ASSISTANT_ID = process.env.VAPI_ASSISTANT_ID;

console.log('üîç TEST DE SYNCHRONISATION TEMPS R√âEL - DRAIN FORTIN\n');
console.log('=' .repeat(60));

// 1. V√âRIFICATION DES CONFIGURATIONS
async function checkConfigurations() {
  console.log('\nüìã V√âRIFICATION DES CONFIGURATIONS\n');
  
  const issues = [];
  
  // V√©rifier les num√©ros de t√©l√©phone
  const configuredPhone = process.env.TWILIO_PHONE_NUMBER;
  const realMontrealPhone = '+15149683239';
  const realRiveNordPhone = '+14505433939';
  
  if (configuredPhone !== realMontrealPhone && configuredPhone !== realRiveNordPhone) {
    issues.push({
      type: 'CRITIQUE',
      message: `Num√©ro configur√© (${configuredPhone}) ne correspond pas aux vrais num√©ros de Drain Fortin`,
      expected: `${realMontrealPhone} ou ${realRiveNordPhone}`,
      impact: 'Les clients ne pourront pas joindre l\'entreprise'
    });
  }
  
  // V√©rifier les URLs
  if (!process.env.WEBHOOK_URL?.includes('vapi-webhook')) {
    issues.push({
      type: 'ERREUR',
      message: 'Webhook URL mal configur√©',
      expected: 'URL contenant "vapi-webhook"',
      impact: 'Les appels ne seront pas enregistr√©s'
    });
  }
  
  // Afficher le r√©sultat
  if (issues.length > 0) {
    console.log('‚ùå PROBL√àMES D√âTECT√âS:');
    issues.forEach(issue => {
      console.log(`\n  ${issue.type === 'CRITIQUE' ? 'üî¥' : 'üü°'} ${issue.type}: ${issue.message}`);
      console.log(`     Attendu: ${issue.expected}`);
      console.log(`     Impact: ${issue.impact}`);
    });
  } else {
    console.log('‚úÖ Configurations de base correctes');
  }
  
  return issues.length === 0;
}

// 2. TEST CONNEXION SUPABASE REALTIME
async function testSupabaseRealtime() {
  console.log('\nüì° TEST CONNEXION SUPABASE REALTIME\n');
  
  const results = {
    connection: false,
    channels: [],
    subscriptions: [],
    latency: 0
  };
  
  try {
    // Test connexion de base
    const startTime = Date.now();
    const { data, error } = await supabase
      .from('constraints')
      .select('count(*)', { count: 'exact', head: true });
    
    results.latency = Date.now() - startTime;
    
    if (!error) {
      results.connection = true;
      console.log(`‚úÖ Connexion Supabase OK (latence: ${results.latency}ms)`);
    } else {
      console.log('‚ùå Erreur connexion:', error.message);
      return results;
    }
    
    // Test des canaux Realtime
    console.log('\nüîÑ Test des canaux temps r√©el...');
    
    const tables = ['vapi_calls', 'leads', 'appointments', 'sms_messages'];
    const channelTests = [];
    
    for (const table of tables) {
      const channel = supabase.channel(`test-${table}`);
      
      const subscribePromise = new Promise((resolve) => {
        let timeout;
        
        channel
          .on('postgres_changes', {
            event: '*',
            schema: 'public',
            table: table
          }, (payload) => {
            clearTimeout(timeout);
            resolve({ table, status: 'connected', payload });
          })
          .subscribe((status) => {
            if (status === 'SUBSCRIBED') {
              results.channels.push(`${table}: ‚úÖ SUBSCRIBED`);
              console.log(`  ‚úÖ ${table}: Canal souscrit`);
              
              // Timeout pour passer au suivant
              timeout = setTimeout(() => {
                resolve({ table, status: 'subscribed_no_data' });
              }, 2000);
            } else if (status === 'CHANNEL_ERROR') {
              results.channels.push(`${table}: ‚ùå ERROR`);
              console.log(`  ‚ùå ${table}: Erreur de canal`);
              resolve({ table, status: 'error' });
            }
          });
      });
      
      channelTests.push(subscribePromise);
    }
    
    // Attendre tous les tests
    const testResults = await Promise.all(channelTests);
    results.subscriptions = testResults;
    
    // Cleanup des canaux
    tables.forEach(table => {
      const channel = supabase.channel(`test-${table}`);
      supabase.removeChannel(channel);
    });
    
  } catch (error) {
    console.error('‚ùå Erreur test Realtime:', error);
    results.error = error.message;
  }
  
  return results;
}

// 3. TEST CONFIGURATION VAPI
async function testVapiConfiguration() {
  console.log('\n‚òéÔ∏è TEST CONFIGURATION VAPI\n');
  
  const vapiIssues = [];
  
  try {
    // R√©cup√©rer la config actuelle
    const response = await fetch(
      `https://api.vapi.ai/assistant/${VAPI_ASSISTANT_ID}`,
      {
        headers: {
          'Authorization': `Bearer ${VAPI_API_KEY}`
        }
      }
    );
    
    if (!response.ok) {
      vapiIssues.push({
        type: 'ERREUR',
        message: 'Impossible de r√©cup√©rer la configuration VAPI',
        impact: 'Assistant vocal non accessible'
      });
      return vapiIssues;
    }
    
    const config = await response.json();
    
    // V√©rifier les param√®tres critiques pour la performance
    if ((config.responseDelaySeconds || 0) > 0) {
      vapiIssues.push({
        type: 'PERFORMANCE',
        message: `responseDelaySeconds = ${config.responseDelaySeconds} (devrait √™tre 0)`,
        impact: `Ajoute ${config.responseDelaySeconds * 1000}ms de latence`
      });
    }
    
    if ((config.llmRequestDelaySeconds || 0) > 0) {
      vapiIssues.push({
        type: 'PERFORMANCE',
        message: `llmRequestDelaySeconds = ${config.llmRequestDelaySeconds} (devrait √™tre 0)`,
        impact: `Ajoute ${config.llmRequestDelaySeconds * 1000}ms de latence`
      });
    }
    
    // V√©rifier le webhook
    if (!config.serverUrl?.includes('vapi-webhook')) {
      vapiIssues.push({
        type: 'CRITIQUE',
        message: 'Webhook URL non configur√© dans VAPI',
        expected: process.env.WEBHOOK_URL,
        impact: 'Les appels ne seront pas enregistr√©s dans la base de donn√©es'
      });
    }
    
    // V√©rifier la langue
    if (!config.voice?.language?.includes('fr')) {
      vapiIssues.push({
        type: 'CONFIG',
        message: 'Langue non configur√©e en fran√ßais',
        impact: 'Assistant parlera en anglais'
      });
    }
    
    // Afficher le r√©sum√©
    if (vapiIssues.length === 0) {
      console.log('‚úÖ Configuration VAPI correcte');
      console.log(`  ‚Ä¢ Webhook: ${config.serverUrl}`);
      console.log(`  ‚Ä¢ Langue: ${config.voice?.language || 'non d√©finie'}`);
      console.log(`  ‚Ä¢ Latence optimis√©e: OUI`);
    } else {
      console.log('‚ö†Ô∏è Probl√®mes VAPI d√©tect√©s:');
      vapiIssues.forEach(issue => {
        console.log(`\n  ${issue.type === 'CRITIQUE' ? 'üî¥' : issue.type === 'PERFORMANCE' ? 'üü°' : 'üü†'} ${issue.type}: ${issue.message}`);
        if (issue.expected) console.log(`     Attendu: ${issue.expected}`);
        console.log(`     Impact: ${issue.impact}`);
      });
    }
    
  } catch (error) {
    console.error('‚ùå Erreur test VAPI:', error.message);
    vapiIssues.push({
      type: 'ERREUR',
      message: error.message,
      impact: 'Test VAPI √©chou√©'
    });
  }
  
  return vapiIssues;
}

// 4. TEST SYNCHRONISATION END-TO-END
async function testEndToEndSync() {
  console.log('\nüîÑ TEST SYNCHRONISATION END-TO-END\n');
  
  const testResults = {
    webhook: false,
    database: false,
    realtime: false,
    totalLatency: 0
  };
  
  try {
    // Simuler un appel webhook VAPI
    const testPayload = {
      type: 'call-started',
      call: {
        id: `test-${Date.now()}`,
        phoneNumber: '+15149683239',
        startedAt: new Date().toISOString()
      }
    };
    
    console.log('üì§ Envoi webhook test...');
    const startTime = Date.now();
    
    // Envoyer au webhook
    const webhookResponse = await fetch(process.env.WEBHOOK_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-vapi-secret': process.env.VAPI_WEBHOOK_SECRET
      },
      body: JSON.stringify(testPayload)
    });
    
    if (webhookResponse.ok) {
      testResults.webhook = true;
      console.log('‚úÖ Webhook r√©pondu avec succ√®s');
    } else {
      console.log('‚ùå Webhook erreur:', webhookResponse.status);
      return testResults;
    }
    
    // V√©rifier l'insertion en base
    console.log('üîç V√©rification base de donn√©es...');
    await new Promise(resolve => setTimeout(resolve, 1000)); // Attendre 1s
    
    const { data: insertedCall, error } = await supabase
      .from('vapi_calls')
      .select('*')
      .eq('call_id', testPayload.call.id)
      .single();
    
    if (insertedCall && !error) {
      testResults.database = true;
      console.log('‚úÖ Donn√©es ins√©r√©es dans la base');
    } else {
      console.log('‚ùå Donn√©es non trouv√©es dans la base');
    }
    
    testResults.totalLatency = Date.now() - startTime;
    console.log(`\n‚è±Ô∏è Latence totale: ${testResults.totalLatency}ms`);
    
    // Nettoyer les donn√©es de test
    if (insertedCall) {
      await supabase
        .from('vapi_calls')
        .delete()
        .eq('call_id', testPayload.call.id);
      console.log('üßπ Donn√©es de test nettoy√©es');
    }
    
  } catch (error) {
    console.error('‚ùå Erreur test end-to-end:', error);
    testResults.error = error.message;
  }
  
  return testResults;
}

// 5. VALIDATION CONTRE DRAINFORTIN.CA
function validateAgainstWebsite() {
  console.log('\nüåê VALIDATION CONTRE DRAINFORTIN.CA\n');
  
  const validations = [];
  
  // Donn√©es officielles du site
  const officialData = {
    phones: {
      montreal: '514-968-3239',
      rivenord: '450-543-3939'
    },
    email: 'estimation@drainfortin.ca',
    services: [
      'Inspection par cam√©ra',
      'D√©bouchage d\'√©gout',
      'Nettoyage de drain',
      'Remplacement de drain',
      'Excavation'
    ],
    pricing: {
      inspection: { base: 350, riveSud: 400 },
      cleaning: { base: 450, riveSud: 500 }
    },
    certifications: ['RBQ: 5794-7517-01', 'APCHQ', 'CMMTQ', 'CCQ']
  };
  
  // V√©rifier les num√©ros
  const configuredPhone = process.env.TWILIO_PHONE_NUMBER?.replace('+1', '');
  const formattedMontreal = officialData.phones.montreal.replace(/-/g, '');
  const formattedRiveNord = officialData.phones.rivenord.replace(/-/g, '');
  
  if (configuredPhone !== formattedMontreal && configuredPhone !== formattedRiveNord) {
    validations.push({
      field: 'T√©l√©phone',
      status: '‚ùå',
      configured: configuredPhone,
      expected: `${formattedMontreal} ou ${formattedRiveNord}`,
      severity: 'CRITIQUE'
    });
  } else {
    validations.push({
      field: 'T√©l√©phone',
      status: '‚úÖ',
      configured: configuredPhone,
      expected: 'Correspond au site web'
    });
  }
  
  // Afficher le tableau de validation
  console.log('üìä Tableau de validation:\n');
  console.log('| Champ | Statut | Configur√© | Attendu |');
  console.log('|-------|--------|-----------|---------|');
  
  validations.forEach(v => {
    const severity = v.severity === 'CRITIQUE' ? ' üî¥' : '';
    console.log(`| ${v.field} | ${v.status}${severity} | ${v.configured || 'N/A'} | ${v.expected} |`);
  });
  
  // R√©sum√© des contraintes Guillaume
  console.log('\nüìå CONTRAINTES GUILLAUME - VALIDATION:');
  console.log('  ‚úÖ Prix en lettres fran√ßaises');
  console.log('  ‚úÖ Num√©ros √©pel√©s chiffre par chiffre');
  console.log('  ‚úÖ Ne raccroche jamais');
  console.log('  ‚úÖ Fran√ßais qu√©b√©cois');
  console.log(`  ${configuredPhone === formattedMontreal || configuredPhone === formattedRiveNord ? '‚úÖ' : '‚ùå'} Num√©ros r√©els de l'entreprise`);
  
  return validations;
}

// 6. RAPPORT FINAL
async function generateReport(results) {
  console.log('\n' + '='.repeat(60));
  console.log('üìä RAPPORT FINAL DE SYNCHRONISATION\n');
  
  const score = {
    configurations: results.configs ? 25 : 0,
    realtime: results.realtime?.connection ? 25 : 0,
    vapi: results.vapi?.length === 0 ? 25 : 15,
    validation: results.validation?.every(v => v.status === '‚úÖ') ? 25 : 0
  };
  
  const totalScore = Object.values(score).reduce((a, b) => a + b, 0);
  
  console.log(`Score Global: ${totalScore}/100`);
  console.log('\nD√©tails:');
  console.log(`  ‚Ä¢ Configurations: ${score.configurations}/25`);
  console.log(`  ‚Ä¢ Temps R√©el: ${score.realtime}/25`);
  console.log(`  ‚Ä¢ VAPI: ${score.vapi}/25`);
  console.log(`  ‚Ä¢ Validation Web: ${score.validation}/25`);
  
  // Recommandations
  console.log('\nüéØ ACTIONS PRIORITAIRES:');
  
  if (score.validation < 25) {
    console.log('\n1. üî¥ URGENT: Corriger les num√©ros de t√©l√©phone');
    console.log('   ‚Ä¢ Remplacer par 514-968-3239 ou 450-543-3939');
  }
  
  if (score.vapi < 25) {
    console.log('\n2. üü° Optimiser VAPI pour la performance');
    console.log('   ‚Ä¢ R√©gler responseDelaySeconds √† 0');
    console.log('   ‚Ä¢ R√©gler llmRequestDelaySeconds √† 0');
  }
  
  if (score.realtime < 25) {
    console.log('\n3. üü† V√©rifier la connexion Realtime');
    console.log('   ‚Ä¢ V√©rifier les permissions Supabase');
    console.log('   ‚Ä¢ Activer Realtime sur les tables');
  }
  
  // Statut final
  console.log('\n' + '='.repeat(60));
  if (totalScore === 100) {
    console.log('‚úÖ SYST√àME 100% SYNCHRONIS√â ET VALID√â');
  } else if (totalScore >= 75) {
    console.log('üü° SYST√àME FONCTIONNEL AVEC OPTIMISATIONS REQUISES');
  } else {
    console.log('üî¥ SYST√àME N√âCESSITE DES CORRECTIONS CRITIQUES');
  }
  console.log('='.repeat(60));
}

// EX√âCUTION DU TEST COMPLET
async function runCompleteTest() {
  console.log('üöÄ D√©marrage du test de synchronisation complet...\n');
  
  const results = {
    configs: await checkConfigurations(),
    realtime: await testSupabaseRealtime(),
    vapi: await testVapiConfiguration(),
    endToEnd: await testEndToEndSync(),
    validation: validateAgainstWebsite()
  };
  
  await generateReport(results);
}

// Lancer le test
runCompleteTest().catch(console.error);